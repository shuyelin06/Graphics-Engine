#include "ConvexHull.h"

#include <assert.h>

#if defined(DRAW_CONVEX_HULL)
#include "math/Compute.h"
#include "rendering/VisualDebug.h"
#endif

namespace Engine {
namespace Math {
ConvexHull::ConvexHull() = default;
ConvexHull::~ConvexHull() = default;

// GetConvexHull:
// Returns the convex hull generated by QuickHull
const std::vector<Triangle>& ConvexHull::getConvexHull() { return convex_hull; }

// GenerateQuickHull:
// Generates a convex hull given a 3D point cloud. Uses the QuickHull algorithm
// to do this.
static constexpr float EPSILON = 0.001f;
static constexpr int UNASSIGNED = -1;
static constexpr int INSIDE = -2;

struct QuickHullPoint {
    Vector3 position;

    // Points are assigned to a face that they're "above".
    int face;

    QuickHullPoint(const Vector3& pos) {
        position = pos;
        face = UNASSIGNED;
    }
};

struct QuickHullFace {
    // Indices of points that comprise the face
    int i_points[3];

    // Indices of faces which border the same edge opposite of point _
    int i_opposite_faces[3];

    // Marks whether or not the face is in the convex hull or not
    bool in_convex_hull;

    // Marks (during the horizon edge search) if the face has been traversed or
    // not
    bool traversal_mark;

    QuickHullFace(int v0, int v1, int v2, int f0, int f1, int f2)
        : i_points{v0, v1, v2}, i_opposite_faces{f0, f1, f2} {
        in_convex_hull = true;
    }
};

struct HorizonEdge {
    int point_1;
    int point_2;

    int visible_face;
    int nonvisible_face;

    HorizonEdge(int p1, int p2, int f1, int f2) {
        point_1 = p1;
        point_2 = p2;
        visible_face = f1;
        nonvisible_face = f2;
    }
};

struct QuickHullSolver {
    std::vector<QuickHullPoint> points;
    std::vector<QuickHullFace> faces;

    QuickHullSolver() = default;

    // Given a face and a point, returns the signed distance of the point to the
    // face. If negative, this means that the point is below the face.
    float signedDistanceTo(int i_face, int i_point) {
        const Vector3& point = points[i_point].position;

        const QuickHullFace& face = faces[i_face];
        const Vector3& v0 = points[face.i_points[0]].position;
        const Vector3& v1 = points[face.i_points[1]].position;
        const Vector3& v2 = points[face.i_points[2]].position;

        const Vector3 normal = (v2 - v0).cross(v1 - v0).unit();

        const float distance = (point - v0).dot(normal);

        return distance;
    }
};

static void generateInitialHull(QuickHullSolver& solver,
                                const std::vector<Vector3>& point_cloud);
static int reassignPointsToFaces(QuickHullSolver& solver);
static void findHorizonEdge(QuickHullSolver& solver, int point, int face,
                            int prev_face,
                            std::vector<HorizonEdge>& horizon_edge);

void ConvexHull::generateQuickHull(const std::vector<Vector3>& point_cloud) {
    convex_hull.clear();

    QuickHullSolver solver = QuickHullSolver();

    // Generate my initial hull, and convert all points to QuickHullPoints.
    generateInitialHull(solver, point_cloud);

    // REPEAT:
    // 1) Choose the furthest point from any given face.
    // 2) Find the faces that the point is above.
    // 3) Remove these faces, and create new ones connecting the horizon edge to
    // the point 4) Update the face indices the points are outside of End when
    // all points are inside the hull.
    bool stop = false;
    std::vector<HorizonEdge> horizon_edge;

    while (!stop) {
        // For every point, assign it to a face that it is outside of.
        // Find the furthest point that is not inside the convex hull.
        int furthest_point = reassignPointsToFaces(solver);

        // If all points are inside the hull, stop.
        if (furthest_point == -1) {
            stop = true;
        } else {
            horizon_edge.clear();
            const QuickHullPoint& point = solver.points[furthest_point];

            for (int i = 0; i < solver.faces.size(); i++)
                solver.faces[i].traversal_mark = false;

            findHorizonEdge(solver, furthest_point, point.face, -1,
                            horizon_edge);

            const int first_index = solver.faces.size();
            int prev_index = solver.faces.size() + horizon_edge.size() - 1;
            int next_index = solver.faces.size() + 1;

            for (const HorizonEdge& edge : horizon_edge) {
                const int new_face_index = solver.faces.size();
                const QuickHullFace new_face =
                    QuickHullFace(edge.point_1, edge.point_2, furthest_point,
                                  next_index, prev_index, edge.nonvisible_face);
                solver.faces.push_back(new_face);

                prev_index = new_face_index;
                next_index = next_index + 1;

                // Remove visible face
                solver.faces[edge.visible_face].in_convex_hull = false;

                // Update non-visible face
                QuickHullFace& nonvisible_face =
                    solver.faces[edge.nonvisible_face];
                if (nonvisible_face.i_opposite_faces[0] == edge.visible_face)
                    nonvisible_face.i_opposite_faces[0] = new_face_index;
                else if (nonvisible_face.i_opposite_faces[1] ==
                         edge.visible_face)
                    nonvisible_face.i_opposite_faces[1] = new_face_index;
                else if (nonvisible_face.i_opposite_faces[2] ==
                         edge.visible_face)
                    nonvisible_face.i_opposite_faces[2] = new_face_index;
                else
                    assert(false);
            }

            solver.faces[solver.faces.size() - 1].i_opposite_faces[0] =
                first_index;
        }
    }

    convex_hull.clear();
    for (const QuickHullFace& face : solver.faces) {
        if (face.in_convex_hull) {
            const Vector3& v0 = solver.points[face.i_points[0]].position;
            const Vector3& v1 = solver.points[face.i_points[1]].position;
            const Vector3& v2 = solver.points[face.i_points[2]].position;

            convex_hull.push_back(Triangle(v0, v1, v2));
        }
    }
}

// GenerateInitialHull:
// Generate the starting hull for the convex hull. This is two triangles on top
// of each other, facing in opposite directions.
void generateInitialHull(QuickHullSolver& solver,
                         const std::vector<Vector3>& point_cloud) {
    // Generate my initial hull, and convert all points to QuickHullPoints.
    // 1) Select min / max points in x to form a line
    // 2) Find the point furthest from this line to form a triangle
    // 3) Generate two triangles, one facing upwards and one facing downwards.
    int a = -1, b = -1, c = -1, d = -1;

    // Find points with min / max x, and register them into the points
    // vector
    for (int i = 0; i < point_cloud.size(); i++) {
        const Vector3& position = point_cloud[i];

        const int point_index = solver.points.size();
        solver.points.push_back(QuickHullPoint(point_cloud[i]));

        if (a == -1 || position.x < solver.points[a].position.x)
            a = point_index;
        if (b == -1 || position.x > solver.points[b].position.x)
            b = point_index;
    }

    assert(a != b);

    // Find the point furthest from the line formed by a --> b.
    const Vector3& a_pos = solver.points[a].position;
    const Vector3& b_pos = solver.points[b].position;
    const Vector3 line_direction = b_pos - a_pos;

    float furthest_distance = -1.f;

    for (int i = 0; i < solver.points.size(); i++) {
        if (i == a || i == b)
            continue;

        const Vector3& point = solver.points[i].position;

        const Vector3 direction = point - a_pos;
        const float distance =
            (direction - line_direction * direction.dot(line_direction))
                .magnitude();

        if (distance > furthest_distance)
            c = i;
    }

    assert(c != -1);

    // Find the point furthest from the plane created by a --> b --> c.
    const Vector3& c_pos = solver.points[c].position;
    const Vector3 normal = (c_pos - a_pos).cross(b_pos - a_pos).unit();

    furthest_distance = -1.f;

    for (int i = 0; i < solver.points.size(); i++) {
        if (i == a || i == b || i == c)
            continue;

        const Vector3& point = solver.points[i].position;
        const float distance = (point - a_pos).dot(normal);
        if (distance > furthest_distance)
            d = i;
    }

    // Create my initial hull, which is a tetrahedron.
    if (d != -1) {
        solver.faces.push_back(QuickHullFace(a, c, b, 2, 3, 1)); // 0
        solver.faces.push_back(QuickHullFace(a, d, c, 2, 0, 3)); // 1
        solver.faces.push_back(QuickHullFace(c, d, b, 3, 0, 1)); // 2
        solver.faces.push_back(QuickHullFace(b, d, a, 1, 0, 2)); // 3
    }
    else {
        furthest_distance = -1.f;

        for (int i = 0; i < solver.points.size(); i++) {
            if (i == a || i == b || i == c)
                continue;

            const Vector3& point = solver.points[i].position;
            const float distance = (point - a_pos).dot(-normal);
            if (distance > furthest_distance)
                d = i;
        }
        
        assert(d != -1);

        solver.faces.push_back(QuickHullFace(a, b, c, 2, 1, 3)); // 0
        solver.faces.push_back(QuickHullFace(a, c, d, 2, 3, 0)); // 1
        solver.faces.push_back(QuickHullFace(c, b, d, 3, 1, 0)); // 2
        solver.faces.push_back(QuickHullFace(b, a, d, 1, 2, 0)); // 3
    }
    
    solver.points[a].face = INSIDE;
    solver.points[b].face = INSIDE;
    solver.points[c].face = INSIDE;
    solver.points[d].face = INSIDE;
}

// ReassignPointsToFaces:
// Assigns each QuickHull point to the face it is above, or inside if it is
// inside of the convex hull. After assignment, returns the point that is
// furthest from its corresponding face.
int reassignPointsToFaces(QuickHullSolver& solver) {
    std::vector<QuickHullPoint>& points = solver.points;
    std::vector<QuickHullFace>& faces = solver.faces;

    int furthest_point = -1;
    float furthest_distance = -1.f;

    for (int i = 0; i < points.size(); i++) {
        QuickHullPoint& point = points[i];

        // Ignore the point if already inside the convex hull
        if (point.face == INSIDE)
            continue;

        point.face = UNASSIGNED;

        // Otherwise, find the first face the point is outside of
        for (int face_index = 0; face_index < faces.size(); face_index++) {
            if (!faces[face_index].in_convex_hull)
                continue;

            const float distance = solver.signedDistanceTo(face_index, i);
            if (distance > EPSILON) {
                point.face = face_index;

                // Save point if it is the furthest point from its face
                if (distance > furthest_distance) {
                    furthest_point = i;
                    furthest_distance = distance;
                }

                break;
            }
        }

        if (point.face == UNASSIGNED)
            point.face = INSIDE;
    }

    return furthest_point;
}

// FindHorizonEdge:
// Finds the horizon edge for a point using a DFS traversal.
void findHorizonEdge(QuickHullSolver& solver, int point, int face,
                     int prev_face, std::vector<HorizonEdge>& horizon_edge) {
    QuickHullFace& cur_face = solver.faces[face];

    // Do not process if already traversed
    if (cur_face.traversal_mark)
        return;
    cur_face.traversal_mark = true;

    if (prev_face == -1) {
        // Attempt to traverse to neighbors.
        // - If neighboring face is visible from point, then the edge we just
        // crossed is not
        //   part of the horizon edge. Continue traversal to the neighbor.
        // - If neighboring face is not visible from point, then the edge we
        // just crossed is part of
        //   the horizon edge. End traversal and add to vector.
        if (solver.signedDistanceTo(cur_face.i_opposite_faces[0], point) >
            EPSILON) {
            findHorizonEdge(solver, point, cur_face.i_opposite_faces[0], face,
                            horizon_edge);
        } else {
            horizon_edge.push_back(HorizonEdge(cur_face.i_points[1],
                                               cur_face.i_points[2], face,
                                               cur_face.i_opposite_faces[0]));
        }

        if (solver.signedDistanceTo(cur_face.i_opposite_faces[1], point) >
            EPSILON) {
            findHorizonEdge(solver, point, cur_face.i_opposite_faces[1], face,
                            horizon_edge);
        } else {
            horizon_edge.push_back(HorizonEdge(cur_face.i_points[2],
                                               cur_face.i_points[0], face,
                                               cur_face.i_opposite_faces[1]));
        }

        if (solver.signedDistanceTo(cur_face.i_opposite_faces[2], point) >
            EPSILON) {
            findHorizonEdge(solver, point, cur_face.i_opposite_faces[2], face,
                            horizon_edge);
        } else {
            horizon_edge.push_back(HorizonEdge(cur_face.i_points[0],
                                               cur_face.i_points[1], face,
                                               cur_face.i_opposite_faces[2]));
        }
    } else {
        int next_index = -1;

        if (prev_face == cur_face.i_opposite_faces[0])
            next_index = 1;
        else if (prev_face == cur_face.i_opposite_faces[1])
            next_index = 2;
        else if (prev_face == cur_face.i_opposite_faces[2])
            next_index = 0;
        else
            assert(false); // Not possible

        if (solver.signedDistanceTo(cur_face.i_opposite_faces[next_index],
                                    point) > EPSILON) {
            findHorizonEdge(solver, point,
                            cur_face.i_opposite_faces[next_index], face,
                            horizon_edge);
        } else {
            horizon_edge.push_back(
                HorizonEdge(cur_face.i_points[(next_index + 1) % 3],
                            cur_face.i_points[(next_index + 2) % 3], face,
                            cur_face.i_opposite_faces[next_index]));
        }

        next_index = (next_index + 1) % 3;
        if (solver.signedDistanceTo(cur_face.i_opposite_faces[next_index],
                                    point) > EPSILON) {
            findHorizonEdge(solver, point,
                            cur_face.i_opposite_faces[next_index], face,
                            horizon_edge);
        } else {
            horizon_edge.push_back(
                HorizonEdge(cur_face.i_points[(next_index + 1) % 3],
                            cur_face.i_points[(next_index + 2) % 3], face,
                            cur_face.i_opposite_faces[next_index]));
        }
    }
}

#if defined(DRAW_CONVEX_HULL)
void ConvexHull::debugDrawConvexHull() const {
    for (const Triangle& triangle : convex_hull) {
        Graphics::VisualDebug::DrawLine(triangle.vertex(0), triangle.vertex(1));
        Graphics::VisualDebug::DrawLine(triangle.vertex(1), triangle.vertex(2));
        Graphics::VisualDebug::DrawLine(triangle.vertex(2), triangle.vertex(0));

        const Vector3 center = triangle.center();
        const Vector3 norm = triangle.normal();
        Graphics::VisualDebug::DrawPoint(center, 0.5f, Color::Blue());
        Graphics::VisualDebug::DrawLine(center, center + norm * 5, Color::Blue());
    }
}
#endif

} // namespace Math
} // namespace Engine