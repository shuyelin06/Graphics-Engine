#pragma once

#include "datamodel/terrain/Terrain.h"

#include "../RenderPass.h"
#include "../core/Asset.h"
#include "../pipeline/StructuredBuffer.h"
#include "../resources/AssetBuilder.h"
#include "VisualTerrainCallback.h"
#include "WaterSurface.h"

namespace Engine {
using namespace Datamodel;

namespace Graphics {
// Data Structures for the terrain structured buffers. These buffers
// will be used in the vertex shader to generate the terrain mesh using vertex
// pulling
struct TBChunkDescriptor {
    unsigned int index_start;
    unsigned int index_count;

    unsigned int vertex_start;
    unsigned int vertex_count;
};

// VisualTerrain Class:
// Interfaces with the datamodel to pull and generate terrain data for the
// visual system. This primarily consists of mesh data. To reduce the number of
// draw calls, VisualTerrain will dynamically group chunk meshes into a single
// vertex / index buffer.
class VisualTerrain {
  private:
    Terrain* terrain;

    // Water Surface
    WaterSurface* water_surface;
    float surface_level;

    // Output Chunk Meshes
    MeshPool* mesh_pool;
    // Stores the most recent terrain meshes
    Mesh* meshes[TERRAIN_CHUNK_COUNT][TERRAIN_CHUNK_COUNT][TERRAIN_CHUNK_COUNT];

    // Stores callback functions that may update with new terrain data
    VisualTerrainCallback callbacks[TERRAIN_CHUNK_COUNT][TERRAIN_CHUNK_COUNT]
                                   [TERRAIN_CHUNK_COUNT];

  public:
    VisualTerrain(Terrain* terrain, ID3D11Device* device);
    ~VisualTerrain();

    // Pull the most recent terrain meshes as generated by the callback
    // functions
    void pullTerrainMeshes(ID3D11DeviceContext* context, RenderPassTerrain& pass_terrain);

    // Return water surface data
    const WaterSurface* getWaterSurface() const;
    float getSurfaceLevel() const;
};

} // namespace Graphics
} // namespace Engine