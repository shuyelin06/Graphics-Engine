#pragma once

#include <queue>

#include "datamodel/terrain/Terrain.h"

#include "rendering/RenderPass.h"
#include "rendering/core/Frustum.h"
#include "rendering/core/Mesh.h"

#include "rendering/pipeline/StructuredBuffer.h"

#include "rendering/resources/MeshBuilder.h"
#include "rendering/resources/ResourceManager.h"

#include "ChunkBuilderJob.h"
#include "WaterSurface.h"

namespace Engine {
using namespace Datamodel;

namespace Graphics {
// Data Structures for the terrain structured buffers. These buffers
// will be used in the vertex shader to generate the terrain mesh using vertex
// pulling
struct TBChunkDescriptor {
    unsigned int index_start;
    unsigned int index_count;

    unsigned int vertex_start;
    unsigned int vertex_count;
};

// VisualTerrain Class:
// Interfaces with the datamodel to pull and generate terrain data for the
// visual system. This primarily consists of mesh data. To reduce the number of
// draw calls, VisualTerrain will dynamically group chunk meshes into a single
// vertex / index buffer.
class VisualTerrain {
  private:
    Terrain* terrain;

    // Water Surface
    WaterSurface* water_surface;
    float surface_level;

    // Output Chunk Meshes
    MeshPool* mesh_pool;

    struct ChunkStatus {
        int chunk_update_id = 0;
        std::shared_ptr<Mesh> mesh = nullptr;
        bool processing = false;
    };
    ChunkStatus chunk_trackers[TERRAIN_CHUNK_COUNT][TERRAIN_CHUNK_COUNT]
                              [TERRAIN_CHUNK_COUNT];

    // Jobs
    std::vector<std::unique_ptr<ChunkBuilderJob>> jobs;
    std::vector<int> inactive_jobs;

    // Dirty (& unprocessed) chunks
    struct DirtyChunk {
        ChunkIndex index;
        float priority;
        bool operator<(const DirtyChunk& other) const {
            return priority < other.priority;
        }
    };
    std::priority_queue<DirtyChunk> dirty_chunks;

  public:
    VisualTerrain(Terrain* terrain, ID3D11DeviceContext* context,
                  ResourceManager& resource_manager);
    ~VisualTerrain();

    // Pull the most recent terrain meshes as generated by the callback
    // functions
    void updateAndUploadTerrainData(ID3D11DeviceContext* context,
                                    RenderPassTerrain& pass_terrain);

    // Return water surface data
    const WaterSurface* getWaterSurface() const;
    float getSurfaceLevel() const;

  private:
    float computeChunkPriority(const ChunkIndex& chunk);
};

} // namespace Graphics
} // namespace Engine