#pragma once

#include "core/Asset.h"
#include "datamodel/terrain/Terrain.h"
#include "datamodel/terrain/TerrainCallback.h"
#include "resources/AssetBuilder.h"

namespace Engine {
using namespace Datamodel;

namespace Graphics {
class BufferPool;
// BufferPool Class
// Manages mesh data for a collection of chunks at once, to reduce the number of
// draw calls needed for the terrain.
struct TerrainTriangle {
    uint32_t i0;
    uint32_t i1;
    uint32_t i2;
};

// BufferAllocation Struct:
// Stores the vertex/index buffer bytes that a terrain chunk
// is allocated in.
struct BufferAllocation {
    uint32_t vertex_start;
    uint32_t vertex_offset;

    uint32_t index_start;
    uint32_t index_offset;

    bool valid;
};

class BufferPool {
  private:
    // CPU-Side Data
    uint32_t v_size;       // Total # Vertices the Pool Supports
    uint32_t vertex_count; // Current # Vertices in the Pool
    Vector3* positions;    // Position Data
    Vector3* normals;      // Normal Data

    uint32_t i_size;         // Total # Triangles the Pool Supports
    uint32_t index_count;    // Current # Triangles
    MeshTriangle* triangles; // Triangle Data

    std::vector<BufferAllocation*> allocations;

    // GPU-Side Data
    ID3D11Buffer* b_position;
    ID3D11Buffer* b_normals;
    ID3D11Buffer* b_index;

  public:
    BufferPool(ID3D11Device* device, uint32_t vbuffer_size,
               uint32_t ibuffer_size);
    ~BufferPool();

    // Allocate / deallocate mesh data on the buffers. Set
    // BufferAllocation.valid to false to deallocate a mesh in the buffer.
    BufferAllocation* allocate(const std::vector<MeshVertex>& vertices,
                               const std::vector<MeshTriangle>& indices);

    // Call before an upload to the GPU.
    // Compacts the buffer data, removing invalid allocations.
    // This will resolve fragmentation.
    void cleanAndCompact();

    // Upload data to the GPU
    void updateGPUResources(ID3D11DeviceContext* context);

    // Retrieve GPU render information
    uint32_t getNumTriangles() const;

    ID3D11Buffer* getPositionBuffer() const;
    ID3D11Buffer* getNormalBuffer() const;
    ID3D11Buffer* getIndexBuffer() const;
};

// VisualTerrainCallback:
// Interfaces with the terrain datamodel to regenerate chunk meshes
// asynchronously.
class VisualTerrainCallback : public TerrainCallback {
  private:
    ID3D11Device* device;

    Mesh* output_mesh;
    MeshBuilder builder;

    std::vector<MeshVertex> vertices;
    std::vector<MeshTriangle> indices;

    bool dirty;

    // Synchronization
    std::mutex mutex;

  public:
    VisualTerrainCallback();

    void initialize(ID3D11Device* device);

    BufferAllocation* loadMesh(BufferPool& pool);
    Mesh* extractMesh();
    bool isDirty();

    void reloadTerrainData(const TerrainChunk* chunk_data);
};

// VisualTerrain Class:
// Interfaces with the datamodel to pull and generate terrain data for the
// visual system. This primarily consists of mesh data. To reduce the number of
// draw calls, VisualTerrain will dynamically group chunk meshes into a single
// vertex / index buffer.
class VisualTerrain {
  private:
    Terrain* terrain;

    // Output Meshes
    BufferPool* output_mesh;

    std::vector<Mesh*> output_meshes;

    // Stores the most recent terrain meshes
    Mesh* chunk_meshes[TERRAIN_CHUNK_COUNT][TERRAIN_CHUNK_COUNT]
                      [TERRAIN_CHUNK_COUNT];
    BufferAllocation* allocations[TERRAIN_CHUNK_COUNT][TERRAIN_CHUNK_COUNT]
                                 [TERRAIN_CHUNK_COUNT];
    // Stores callback functions that may update with new terrain data
    VisualTerrainCallback callbacks[TERRAIN_CHUNK_COUNT][TERRAIN_CHUNK_COUNT]
                                   [TERRAIN_CHUNK_COUNT];

  public:
    VisualTerrain(Terrain* terrain, ID3D11Device* device);
    ~VisualTerrain();

    // Pull the most recent terrain meshes as generated by the callback
    // functions
    void pullTerrainMeshes(ID3D11DeviceContext* context);

    // Return the current meshes for rendering.
    const std::vector<Mesh*>& getTerrainMeshes();
    BufferPool* getMesh();

#if defined(_DEBUG)
    void imGuiDisplay(); 
#endif
};

} // namespace Graphics
} // namespace Engine